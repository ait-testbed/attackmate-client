{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"cli-examples/","text":"CLI Examples This page provides practical examples of using the attackmate-client CLI in various scenarios. Basic Examples Simple Execution Execute a playbook with minimal options: uv run attackmate-client playbook.yaml \\ --username admin \\ --password adminpass Custom Server Connect to a specific AttackMate server: uv run attackmate-client playbook.yaml \\ --server-url https://attackmate.example.com:8445 \\ --username testuser \\ --password testpass Self-Signed Certificate Execute with a self-signed SSL certificate: uv run attackmate-client playbook.yaml \\ --username admin \\ --password adminpass \\ --cacert /etc/ssl/certs/attackmate-ca.crt Debug Mode Enable debug logging for troubleshooting: uv run attackmate-client playbook.yaml \\ --username admin \\ --password adminpass \\ --debug Tips and Tricks Credential File (Simple) Create a credentials file ~/.attackmate/credentials : ATTACKMATE_SERVER=\"https://attackmate.example.com:8445\" ATTACKMATE_USER=\"your_username\" ATTACKMATE_PASS=\"your_password\" ATTACKMATE_CACERT=\"/etc/ssl/certs/attackmate-ca.crt\" Source it before running: source ~/.attackmate/credentials uv run attackmate-client playbook.yaml \\ --server-url \"$ATTACKMATE_SERVER\" \\ --username \"$ATTACKMATE_USER\" \\ --password \"$ATTACKMATE_PASS\" \\ --cacert \"$ATTACKMATE_CACERT\" Next Steps Learn about the Python API for programmatic access","title":"Examples"},{"location":"cli-examples/#cli-examples","text":"This page provides practical examples of using the attackmate-client CLI in various scenarios.","title":"CLI Examples"},{"location":"cli-examples/#basic-examples","text":"","title":"Basic Examples"},{"location":"cli-examples/#simple-execution","text":"Execute a playbook with minimal options: uv run attackmate-client playbook.yaml \\ --username admin \\ --password adminpass","title":"Simple Execution"},{"location":"cli-examples/#custom-server","text":"Connect to a specific AttackMate server: uv run attackmate-client playbook.yaml \\ --server-url https://attackmate.example.com:8445 \\ --username testuser \\ --password testpass","title":"Custom Server"},{"location":"cli-examples/#self-signed-certificate","text":"Execute with a self-signed SSL certificate: uv run attackmate-client playbook.yaml \\ --username admin \\ --password adminpass \\ --cacert /etc/ssl/certs/attackmate-ca.crt","title":"Self-Signed Certificate"},{"location":"cli-examples/#debug-mode","text":"Enable debug logging for troubleshooting: uv run attackmate-client playbook.yaml \\ --username admin \\ --password adminpass \\ --debug","title":"Debug Mode"},{"location":"cli-examples/#tips-and-tricks","text":"","title":"Tips and Tricks"},{"location":"cli-examples/#credential-file-simple","text":"Create a credentials file ~/.attackmate/credentials : ATTACKMATE_SERVER=\"https://attackmate.example.com:8445\" ATTACKMATE_USER=\"your_username\" ATTACKMATE_PASS=\"your_password\" ATTACKMATE_CACERT=\"/etc/ssl/certs/attackmate-ca.crt\" Source it before running: source ~/.attackmate/credentials uv run attackmate-client playbook.yaml \\ --server-url \"$ATTACKMATE_SERVER\" \\ --username \"$ATTACKMATE_USER\" \\ --password \"$ATTACKMATE_PASS\" \\ --cacert \"$ATTACKMATE_CACERT\"","title":"Credential File (Simple)"},{"location":"cli-examples/#next-steps","text":"Learn about the Python API for programmatic access","title":"Next Steps"},{"location":"cli-overview/","text":"","title":"Overview"},{"location":"client-examples/","text":"API Code Examples This page provides comprehensive code examples for integrating the RemoteAttackMateClient into your Python applications. Basic Usage Simple Playbook Execution from attackmate_client import RemoteAttackMateClient # Initialize the client client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"mypassword\" ) # Read and execute playbook with open(\"playbook.yaml\", \"r\") as f: playbook_content = f.read() result = client.execute_remote_playbook_yaml(playbook_content) # Check results if result and result.get(\"success\"): print(\"\u2713 Playbook executed successfully!\") else: print(\"\u2717 Playbook execution failed\") With Self-Signed Certificate from attackmate_client import RemoteAttackMateClient client = RemoteAttackMateClient( server_url=\"https://localhost:8445\", username=\"admin\", password=\"adminpass\", cacert=\"/path/to/self-signed-ca.crt\" ) with open(\"test.yaml\", \"r\") as f: result = client.execute_remote_playbook_yaml(f.read(), debug=True) if result: print(f\"Message: {result.get('message')}\") Error Handling Patterns Basic Error Handling from attackmate_client import RemoteAttackMateClient import sys client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"password\" ) try: with open(\"playbook.yaml\", \"r\") as f: yaml_content = f.read() except FileNotFoundError: print(\"ERROR: Playbook file not found\") sys.exit(1) except IOError as e: print(f\"ERROR: Cannot read playbook: {e}\") sys.exit(1) result = client.execute_remote_playbook_yaml(yaml_content) if not result: print(\"ERROR: No result returned from server (auth/network failure)\") sys.exit(1) if not result.get(\"success\"): print(f\"ERROR: Playbook failed: {result.get('message')}\") sys.exit(1) print(\"SUCCESS: Playbook completed\")","title":"Code Examples"},{"location":"client-examples/#api-code-examples","text":"This page provides comprehensive code examples for integrating the RemoteAttackMateClient into your Python applications.","title":"API Code Examples"},{"location":"client-examples/#basic-usage","text":"","title":"Basic Usage"},{"location":"client-examples/#simple-playbook-execution","text":"from attackmate_client import RemoteAttackMateClient # Initialize the client client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"mypassword\" ) # Read and execute playbook with open(\"playbook.yaml\", \"r\") as f: playbook_content = f.read() result = client.execute_remote_playbook_yaml(playbook_content) # Check results if result and result.get(\"success\"): print(\"\u2713 Playbook executed successfully!\") else: print(\"\u2717 Playbook execution failed\")","title":"Simple Playbook Execution"},{"location":"client-examples/#with-self-signed-certificate","text":"from attackmate_client import RemoteAttackMateClient client = RemoteAttackMateClient( server_url=\"https://localhost:8445\", username=\"admin\", password=\"adminpass\", cacert=\"/path/to/self-signed-ca.crt\" ) with open(\"test.yaml\", \"r\") as f: result = client.execute_remote_playbook_yaml(f.read(), debug=True) if result: print(f\"Message: {result.get('message')}\")","title":"With Self-Signed Certificate"},{"location":"client-examples/#error-handling-patterns","text":"","title":"Error Handling Patterns"},{"location":"client-examples/#basic-error-handling","text":"from attackmate_client import RemoteAttackMateClient import sys client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"password\" ) try: with open(\"playbook.yaml\", \"r\") as f: yaml_content = f.read() except FileNotFoundError: print(\"ERROR: Playbook file not found\") sys.exit(1) except IOError as e: print(f\"ERROR: Cannot read playbook: {e}\") sys.exit(1) result = client.execute_remote_playbook_yaml(yaml_content) if not result: print(\"ERROR: No result returned from server (auth/network failure)\") sys.exit(1) if not result.get(\"success\"): print(f\"ERROR: Playbook failed: {result.get('message')}\") sys.exit(1) print(\"SUCCESS: Playbook completed\")","title":"Basic Error Handling"},{"location":"client/","text":"RemoteAttackMateClient API Reference The RemoteAttackMateClient class provides a Python API for interacting with the AttackMate server programmatically. Class Overview from attackmate_client import RemoteAttackMateClient The RemoteAttackMateClient handles: Authentication and token management SSL/TLS certificate verification HTTP request lifecycle Session management across multiple API calls Error handling and logging Constructor __init__() RemoteAttackMateClient( server_url: str, cacert: Optional[str] = None, username: Optional[str] = None, password: Optional[str] = None, timeout: float = 60.0 ) Creates a new client instance for communicating with an AttackMate server. Parameters Parameter Type Required Default Description server_url str Yes - Base URL of the AttackMate API server (e.g., \"https://attackmate.example.com:8445\" ) cacert Optional[str] No None Path to CA certificate file for SSL verification. Use for self-signed certificates. username Optional[str] No None Username for authentication. Required if making authenticated requests. password Optional[str] No None Password for authentication. Required if making authenticated requests. timeout float No 60.0 Request timeout in seconds for long-running playbooks. Example client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"secure_password\", cacert=\"/path/to/ca-cert.pem\", timeout=120.0 # 2 minutes ) Raises No exceptions are raised during initialization. Connection and authentication errors occur during method calls. Methods execute_remote_playbook_yaml() Executes a playbook by sending its YAML content to the remote server. def execute_remote_playbook_yaml( self, playbook_yaml_content: str, debug: bool = False ) -> Optional[Dict[str, Any]] Parameters Parameter Type Required Default Description playbook_yaml_content str Yes - Complete YAML content of the playbook to execute debug bool No False Enable server-side debug logging for this execution Returns On success : Dict[str, Any] containing: python { \"success\": bool, # Execution success status \"message\": str, # Status or error message \"final_state\": { # Final execution state \"variables\": dict, # Variable store after execution # ... other state fields }, \"current_token\": str # Renewed authentication token (optional) } On failure : None Example with open(\"playbook.yaml\", \"r\") as f: yaml_content = f.read() result = client.execute_remote_playbook_yaml( playbook_yaml_content=yaml_content, debug=True ) if result and result.get(\"success\"): print(\"Playbook executed successfully!\") variables = result.get(\"final_state\", {}).get(\"variables\", {}) print(f\"Final variables: {variables}\") else: print(\"Playbook execution failed\") Raises Does not raise exceptions. Returns None on errors. Check logs for details. execute_remote_command() Executes a single command using a Pydantic model. def execute_remote_command( self, command_pydantic_model, debug: bool = False ) -> Optional[Dict[str, Any]] Parameters Parameter Type Required Default Description command_pydantic_model Pydantic Model Yes - Pydantic model instance representing the command to execute debug bool No False Enable server-side debug logging Returns Similar structure to execute_remote_playbook_yaml() : On success : Dict[str, Any] with execution results On failure : None Example from pydantic import BaseModel class ShellCommand(BaseModel): command: str args: list[str] command = ShellCommand( command=\"echo\", args=[\"Hello, AttackMate!\"] ) result = client.execute_remote_command(command, debug=False) if result: print(f\"Command result: {result.get('message')}\") Raises Does not raise exceptions. Returns None on errors. Properties and Internal Methods The following methods are internal and typically not called directly: _get_session_token() (Internal) Retrieves or creates an authentication token. Called automatically by request methods. _login() (Internal) Performs authentication and stores the token. Called automatically when needed. _make_request() (Internal) Generic HTTP request handler. Manages token renewal and error handling. Session Management The client maintains session state globally per server URL: # Token storage is managed automatically _active_sessions: Dict[str, Dict[str, str]] = {} How It Works First request : Client authenticates and stores token Subsequent requests : Client reuses stored token Token expiration : Server returns renewed token, client updates cache 401 Unauthorized : Client clears cached token, re-authenticates on next request Multiple Clients, Same Server # Both clients share the same token for this server client1 = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"user1\", password=\"pass1\" ) client2 = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"user1\", # Same user password=\"pass1\" ) # First client authenticates result1 = client1.execute_remote_playbook_yaml(yaml_content) # Second client reuses the token (no re-authentication needed) result2 = client2.execute_remote_playbook_yaml(yaml_content) Different Users, Same Server # Different users get different tokens admin_client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"admin_pass\" ) user_client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"regular_user\", password=\"user_pass\" ) # Each client gets its own token admin_result = admin_client.execute_remote_playbook_yaml(yaml_content) user_result = user_client.execute_remote_playbook_yaml(yaml_content) Error Handling The client handles errors gracefully without raising exceptions: Common Scenarios Scenario Behavior Return Value Authentication failure Logs error None Network error Logs error None HTTP 4xx/5xx error Logs status and detail None Token expired (401) Clears token, logs warning None (will re-auth on retry) Invalid JSON response Logs decode error None SSL verification failure Logs error None Checking for Errors result = client.execute_remote_playbook_yaml(yaml_content) if result is None: print(\"ERROR: Request failed - check logs\") exit(1) if not result.get(\"success\"): print(f\"ERROR: Playbook failed - {result.get('message')}\") exit(1) print(\"Success!\") Logging The client uses Python's logging module. Configure logging to see detailed information: import logging # Enable debug logging logging.basicConfig( level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' ) # Now client operations will be logged client = RemoteAttackMateClient(...) Log Levels DEBUG : HTTP requests, token management, detailed flow INFO : Authentication success, token renewal WARNING : Token expiration, retryable issues ERROR : Request failures, authentication errors Type Hints The client is fully type-hinted for IDE support: from typing import Dict, Any, Optional result: Optional[Dict[str, Any]] = client.execute_remote_playbook_yaml( playbook_yaml_content=yaml_str, debug=False ) if result: success: bool = result.get(\"success\", False) message: str = result.get(\"message\", \"\") Thread Safety Not Thread-Safe The global _active_sessions dictionary is not thread-safe . If using the client in a multi-threaded application, implement your own locking mechanism or create separate client instances per thread. Complete Example import logging from attackmate_client import RemoteAttackMateClient # Configure logging logging.basicConfig(level=logging.INFO) # Initialize client client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"secure_password\", cacert=\"/etc/ssl/certs/attackmate-ca.crt\", timeout=180.0 ) # Read playbook with open(\"security_scan.yaml\", \"r\") as f: playbook_yaml = f.read() # Execute playbook result = client.execute_remote_playbook_yaml( playbook_yaml_content=playbook_yaml, debug=True ) # Handle result if not result: print(\"ERROR: Request failed\") exit(1) if result.get(\"success\"): print(f\"\u2713 Success: {result.get('message')}\") # Access final state final_state = result.get(\"final_state\", {}) variables = final_state.get(\"variables\", {}) print(\"\\nFinal Variables:\") for key, value in variables.items(): print(f\" {key}: {value}\") else: print(f\"\u2717 Failed: {result.get('message')}\") exit(1) Next Steps See Code Examples for practical integration patterns","title":"RemoteAttackMateClient"},{"location":"client/#remoteattackmateclient-api-reference","text":"The RemoteAttackMateClient class provides a Python API for interacting with the AttackMate server programmatically.","title":"RemoteAttackMateClient API Reference"},{"location":"client/#class-overview","text":"from attackmate_client import RemoteAttackMateClient The RemoteAttackMateClient handles: Authentication and token management SSL/TLS certificate verification HTTP request lifecycle Session management across multiple API calls Error handling and logging","title":"Class Overview"},{"location":"client/#constructor","text":"","title":"Constructor"},{"location":"client/#__init__","text":"RemoteAttackMateClient( server_url: str, cacert: Optional[str] = None, username: Optional[str] = None, password: Optional[str] = None, timeout: float = 60.0 ) Creates a new client instance for communicating with an AttackMate server.","title":"__init__()"},{"location":"client/#parameters","text":"Parameter Type Required Default Description server_url str Yes - Base URL of the AttackMate API server (e.g., \"https://attackmate.example.com:8445\" ) cacert Optional[str] No None Path to CA certificate file for SSL verification. Use for self-signed certificates. username Optional[str] No None Username for authentication. Required if making authenticated requests. password Optional[str] No None Password for authentication. Required if making authenticated requests. timeout float No 60.0 Request timeout in seconds for long-running playbooks.","title":"Parameters"},{"location":"client/#example","text":"client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"secure_password\", cacert=\"/path/to/ca-cert.pem\", timeout=120.0 # 2 minutes )","title":"Example"},{"location":"client/#raises","text":"No exceptions are raised during initialization. Connection and authentication errors occur during method calls.","title":"Raises"},{"location":"client/#methods","text":"","title":"Methods"},{"location":"client/#execute_remote_playbook_yaml","text":"Executes a playbook by sending its YAML content to the remote server. def execute_remote_playbook_yaml( self, playbook_yaml_content: str, debug: bool = False ) -> Optional[Dict[str, Any]]","title":"execute_remote_playbook_yaml()"},{"location":"client/#parameters_1","text":"Parameter Type Required Default Description playbook_yaml_content str Yes - Complete YAML content of the playbook to execute debug bool No False Enable server-side debug logging for this execution","title":"Parameters"},{"location":"client/#returns","text":"On success : Dict[str, Any] containing: python { \"success\": bool, # Execution success status \"message\": str, # Status or error message \"final_state\": { # Final execution state \"variables\": dict, # Variable store after execution # ... other state fields }, \"current_token\": str # Renewed authentication token (optional) } On failure : None","title":"Returns"},{"location":"client/#example_1","text":"with open(\"playbook.yaml\", \"r\") as f: yaml_content = f.read() result = client.execute_remote_playbook_yaml( playbook_yaml_content=yaml_content, debug=True ) if result and result.get(\"success\"): print(\"Playbook executed successfully!\") variables = result.get(\"final_state\", {}).get(\"variables\", {}) print(f\"Final variables: {variables}\") else: print(\"Playbook execution failed\")","title":"Example"},{"location":"client/#raises_1","text":"Does not raise exceptions. Returns None on errors. Check logs for details.","title":"Raises"},{"location":"client/#execute_remote_command","text":"Executes a single command using a Pydantic model. def execute_remote_command( self, command_pydantic_model, debug: bool = False ) -> Optional[Dict[str, Any]]","title":"execute_remote_command()"},{"location":"client/#parameters_2","text":"Parameter Type Required Default Description command_pydantic_model Pydantic Model Yes - Pydantic model instance representing the command to execute debug bool No False Enable server-side debug logging","title":"Parameters"},{"location":"client/#returns_1","text":"Similar structure to execute_remote_playbook_yaml() : On success : Dict[str, Any] with execution results On failure : None","title":"Returns"},{"location":"client/#example_2","text":"from pydantic import BaseModel class ShellCommand(BaseModel): command: str args: list[str] command = ShellCommand( command=\"echo\", args=[\"Hello, AttackMate!\"] ) result = client.execute_remote_command(command, debug=False) if result: print(f\"Command result: {result.get('message')}\")","title":"Example"},{"location":"client/#raises_2","text":"Does not raise exceptions. Returns None on errors.","title":"Raises"},{"location":"client/#properties-and-internal-methods","text":"The following methods are internal and typically not called directly:","title":"Properties and Internal Methods"},{"location":"client/#_get_session_token-internal","text":"Retrieves or creates an authentication token. Called automatically by request methods.","title":"_get_session_token() (Internal)"},{"location":"client/#_login-internal","text":"Performs authentication and stores the token. Called automatically when needed.","title":"_login() (Internal)"},{"location":"client/#_make_request-internal","text":"Generic HTTP request handler. Manages token renewal and error handling.","title":"_make_request() (Internal)"},{"location":"client/#session-management","text":"The client maintains session state globally per server URL: # Token storage is managed automatically _active_sessions: Dict[str, Dict[str, str]] = {}","title":"Session Management"},{"location":"client/#how-it-works","text":"First request : Client authenticates and stores token Subsequent requests : Client reuses stored token Token expiration : Server returns renewed token, client updates cache 401 Unauthorized : Client clears cached token, re-authenticates on next request","title":"How It Works"},{"location":"client/#multiple-clients-same-server","text":"# Both clients share the same token for this server client1 = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"user1\", password=\"pass1\" ) client2 = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"user1\", # Same user password=\"pass1\" ) # First client authenticates result1 = client1.execute_remote_playbook_yaml(yaml_content) # Second client reuses the token (no re-authentication needed) result2 = client2.execute_remote_playbook_yaml(yaml_content)","title":"Multiple Clients, Same Server"},{"location":"client/#different-users-same-server","text":"# Different users get different tokens admin_client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"admin_pass\" ) user_client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"regular_user\", password=\"user_pass\" ) # Each client gets its own token admin_result = admin_client.execute_remote_playbook_yaml(yaml_content) user_result = user_client.execute_remote_playbook_yaml(yaml_content)","title":"Different Users, Same Server"},{"location":"client/#error-handling","text":"The client handles errors gracefully without raising exceptions:","title":"Error Handling"},{"location":"client/#common-scenarios","text":"Scenario Behavior Return Value Authentication failure Logs error None Network error Logs error None HTTP 4xx/5xx error Logs status and detail None Token expired (401) Clears token, logs warning None (will re-auth on retry) Invalid JSON response Logs decode error None SSL verification failure Logs error None","title":"Common Scenarios"},{"location":"client/#checking-for-errors","text":"result = client.execute_remote_playbook_yaml(yaml_content) if result is None: print(\"ERROR: Request failed - check logs\") exit(1) if not result.get(\"success\"): print(f\"ERROR: Playbook failed - {result.get('message')}\") exit(1) print(\"Success!\")","title":"Checking for Errors"},{"location":"client/#logging","text":"The client uses Python's logging module. Configure logging to see detailed information: import logging # Enable debug logging logging.basicConfig( level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' ) # Now client operations will be logged client = RemoteAttackMateClient(...)","title":"Logging"},{"location":"client/#log-levels","text":"DEBUG : HTTP requests, token management, detailed flow INFO : Authentication success, token renewal WARNING : Token expiration, retryable issues ERROR : Request failures, authentication errors","title":"Log Levels"},{"location":"client/#type-hints","text":"The client is fully type-hinted for IDE support: from typing import Dict, Any, Optional result: Optional[Dict[str, Any]] = client.execute_remote_playbook_yaml( playbook_yaml_content=yaml_str, debug=False ) if result: success: bool = result.get(\"success\", False) message: str = result.get(\"message\", \"\")","title":"Type Hints"},{"location":"client/#thread-safety","text":"Not Thread-Safe The global _active_sessions dictionary is not thread-safe . If using the client in a multi-threaded application, implement your own locking mechanism or create separate client instances per thread.","title":"Thread Safety"},{"location":"client/#complete-example","text":"import logging from attackmate_client import RemoteAttackMateClient # Configure logging logging.basicConfig(level=logging.INFO) # Initialize client client = RemoteAttackMateClient( server_url=\"https://attackmate.example.com:8445\", username=\"admin\", password=\"secure_password\", cacert=\"/etc/ssl/certs/attackmate-ca.crt\", timeout=180.0 ) # Read playbook with open(\"security_scan.yaml\", \"r\") as f: playbook_yaml = f.read() # Execute playbook result = client.execute_remote_playbook_yaml( playbook_yaml_content=playbook_yaml, debug=True ) # Handle result if not result: print(\"ERROR: Request failed\") exit(1) if result.get(\"success\"): print(f\"\u2713 Success: {result.get('message')}\") # Access final state final_state = result.get(\"final_state\", {}) variables = final_state.get(\"variables\", {}) print(\"\\nFinal Variables:\") for key, value in variables.items(): print(f\" {key}: {value}\") else: print(f\"\u2717 Failed: {result.get('message')}\") exit(1)","title":"Complete Example"},{"location":"client/#next-steps","text":"See Code Examples for practical integration patterns","title":"Next Steps"},{"location":"installation/","text":"","title":"Installation"},{"location":"license/","text":"","title":"License"},{"location":"quickstart/","text":"Quick Start Get started with AttackMate Client in minutes. Prerequisites Installed AttackMate Client Access to an AttackMate API server Valid credentials (username and password) A playbook YAML file Execute Your First Playbook Basic Example uv run attackmate-client playbook.yaml \\ --server-url https://attackmate.example.com:8445 \\ --username admin \\ --password mypassword With Self-Signed Certificate uv run attackmate-client playbook.yaml \\ --server-url https://localhost:8445 \\ --username admin \\ --password adminpass \\ --cacert /path/to/server-ca.crt With Debug Mode uv run attackmate-client playbook.yaml \\ --server-url https://localhost:8445 \\ --username admin \\ --password adminpass \\ --debug Successful Output --- Playbook Execution (YAML: playbook.yaml) Result --- Success: True Message: Playbook executed successfully --- Final Variable Store State --- target_ip: 192.168.1.100 Common Issues Issue Solution Authentication failed Verify username and password SSL: CERTIFICATE_VERIFY_FAILED Use --cacert with CA certificate path Connection refused Check server URL and ensure server is running Playbook file not found Verify file path is correct Next Steps CLI Usage Guide - Learn all CLI options CLI Examples - See practical examples Python API - Use in your scripts","title":"Quick Start"},{"location":"quickstart/#quick-start","text":"Get started with AttackMate Client in minutes.","title":"Quick Start"},{"location":"quickstart/#prerequisites","text":"Installed AttackMate Client Access to an AttackMate API server Valid credentials (username and password) A playbook YAML file","title":"Prerequisites"},{"location":"quickstart/#execute-your-first-playbook","text":"","title":"Execute Your First Playbook"},{"location":"quickstart/#basic-example","text":"uv run attackmate-client playbook.yaml \\ --server-url https://attackmate.example.com:8445 \\ --username admin \\ --password mypassword","title":"Basic Example"},{"location":"quickstart/#with-self-signed-certificate","text":"uv run attackmate-client playbook.yaml \\ --server-url https://localhost:8445 \\ --username admin \\ --password adminpass \\ --cacert /path/to/server-ca.crt","title":"With Self-Signed Certificate"},{"location":"quickstart/#with-debug-mode","text":"uv run attackmate-client playbook.yaml \\ --server-url https://localhost:8445 \\ --username admin \\ --password adminpass \\ --debug","title":"With Debug Mode"},{"location":"quickstart/#successful-output","text":"--- Playbook Execution (YAML: playbook.yaml) Result --- Success: True Message: Playbook executed successfully --- Final Variable Store State --- target_ip: 192.168.1.100","title":"Successful Output"},{"location":"quickstart/#common-issues","text":"Issue Solution Authentication failed Verify username and password SSL: CERTIFICATE_VERIFY_FAILED Use --cacert with CA certificate path Connection refused Check server URL and ensure server is running Playbook file not found Verify file path is correct","title":"Common Issues"},{"location":"quickstart/#next-steps","text":"CLI Usage Guide - Learn all CLI options CLI Examples - See practical examples Python API - Use in your scripts","title":"Next Steps"}]}